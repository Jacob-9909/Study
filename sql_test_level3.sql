-- 대장균의 크기에 따라 분류하기 1 --
SELECT ID, CASE
WHEN SIZE_OF_COLONY <= 100 THEN 'LOW'
WHEN SIZE_OF_COLONY <= 1000 THEN 'MEDIUM'
ELSE 'HIGH'
END AS SIZE
FROM ECOLI_DATA
ORDER BY ID;


-- 대장균의 크기에 따라 분류하기 2 --
SELECT A.ID,
       CASE
           WHEN A.PER <= 0.25 THEN 'CRITICAL'
           WHEN A.PER <= 0.5 THEN 'HIGH'
           WHEN A.PER <= 0.75 THEN 'MEDIUM'
           ELSE 'LOW'
       END AS COLONY_NAME
FROM (
    SELECT ID, SIZE_OF_COLONY,
           (RANK() OVER (ORDER BY SIZE_OF_COLONY DESC) - 1) / (COUNT(*) OVER () - 1) AS PER
    FROM ECOLI_DATA
) AS A
ORDER BY A.ID;


-- 대장균들의 자식의 수 구하기 -- 
SELECT A.ID AS ID, COUNT(B.ID) AS CHILD_COUNT
FROM ECOLI_DATA AS A LEFT JOIN ECOLI_DATA AS B
ON A.ID = B.PARENT_ID
GROUP BY 1
ORDER BY 1


-- 특정 조건을 만족하는 물고기별 수와 최대 길이 구하기 --
SELECT FISH_COUNT, MAX_LENGTH, FISH_TYPE
FROM (
    SELECT F.FISH_TYPE, COUNT(F.ID) AS FISH_COUNT, MAX(F.LENGTH) AS MAX_LENGTH, AVG(F.LENGTH) AS AVG_LENGTH
    FROM (
        SELECT ID, FISH_TYPE,CASE WHEN LENGTH <= 10 OR LENGTH IS NULL THEN 10 ELSE LENGTH END AS LENGTH
        FROM FISH_INFO
    ) AS F
    GROUP BY F.FISH_TYPE
) AS T
WHERE T.AVG_LENGTH >= 33
ORDER BY T.FISH_TYPE ASC;

-- 물고기 종류 별 대어 찾기 --
SELECT I.ID, N.FISH_NAME, I.LENGTH
FROM FISH_INFO AS I JOIN FISH_NAME_INFO AS N
ON I.FISH_TYPE = N.FISH_TYPE
WHERE I.LENGTH IN (
    SELECT MAX(LENGTH)
    FROM FISH_INFO
    GROUP BY FISH_TYPE
    HAVING FISH_TYPE = I.FISH_TYPE
)
ORDER BY I.ID;


-- 부서별 평균 연봉 조회하기 -- 
SELECT D.DEPT_ID, D.DEPT_NAME_EN, ROUND(AVG(E.SAL),0) AS AVG_SAL
FROM HR_DEPARTMENT AS D
JOIN HR_EMPLOYEES AS E ON D.DEPT_ID = E.DEPT_ID
GROUP BY D.DEPT_ID, D.DEPT_NAME_EN
ORDER BY AVG_SAL DESC;


-- 업그레이드 할 수 없는 아이템 구하기 --
SELECT I.ITEM_ID, I.ITEM_NAME, I.RARITY
FROM ITEM_INFO AS I LEFT JOIN ITEM_TREE AS T
ON I.ITEM_ID = T.PARENT_ITEM_ID
WHERE T.ITEM_ID IS NULL
ORDER BY I.ITEM_ID DESC;


-- 조회수가 가장 많은 중고거래 게시판의 첨부파일 조회하기 --
SELECT CONCAT('/home/grep/src/',F.BOARD_ID,'/',F.FILE_ID,F.FILE_NAME,F.FILE_EXT) AS FILE_PATH 
FROM USED_GOODS_FILE AS F JOIN USED_GOODS_BOARD AS B
ON F.BOARD_ID=B.BOARD_ID
WHERE B.VIEWS = (SELECT MAX(VIEWS) AS MAX_VIEWS
                FROM USED_GOODS_BOARD)
ORDER BY F.FILE_ID DESC;


-- 조건에 맞는 사용자 정보 조회하기 -- 
SELECT DISTINCT 
    U.USER_ID, 
    U.NICKNAME, 
    CONCAT(U.CITY, ' ', U.STREET_ADDRESS1, ' ', U.STREET_ADDRESS2) AS '전체주소', 
    CONCAT(SUBSTR(U.TLNO, 1, 3), '-', SUBSTR(U.TLNO, 4, 4), '-', SUBSTR(U.TLNO, 8, 4)) AS 전화번호
FROM 
    USED_GOODS_USER AS U
WHERE 
    U.USER_ID IN (
        SELECT 
            WRITER_ID
        FROM 
            USED_GOODS_BOARD
        GROUP BY 
            WRITER_ID
        HAVING 
            COUNT(BOARD_ID) >= 3
    )
ORDER BY 
    U.USER_ID DESC;


-- 조건에 맞는 사용자와 총 거래금액 조회하기 --
SELECT  U.USER_ID, U.NICKNAME, SUM(B.PRICE) AS TOTAL_SALES
FROM USED_GOODS_BOARD AS B JOIN USED_GOODS_USER AS U 
ON B.WRITER_ID = U.USER_ID
WHERE B.STATUS LIKE 'DONE'
GROUP BY U.USER_ID
HAVING SUM(B.PRICE) >= 700000
ORDER BY SUM(B.PRICE);


-- 대여 기록이 존재하는 자동차 리스트 구하기 --
SELECT DISTINCT C.CAR_ID 
FROM CAR_RENTAL_COMPANY_CAR AS C JOIN CAR_RENTAL_COMPANY_RENTAL_HISTORY AS R
ON C.CAR_ID = R.CAR_ID
WHERE C.CAR_TYPE LIKE '세단' AND MONTH(R.START_DATE) LIKE 10
ORDER BY C.CAR_ID DESC;


-- 자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기 -- 
SELECT CAR_ID,
    CASE WHEN MAX(AVAILABILITY) = '1' THEN '대여중'
    ELSE '대여 가능' END AS AVAILABILITY
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY AS A
    LEFT JOIN (SELECT HISTORY_ID, '1' AS AVAILABILITY FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY WHERE START_DATE <= '2022-10-16' AND END_DATE >= '2022-10-16') AS B
    ON A.HISTORY_ID = B.HISTORY_ID
GROUP BY CAR_ID
ORDER BY CAR_ID DESC;


-- 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기 --
SELECT MONTH(START_DATE) AS 'MONTH', CAR_ID, COUNT(*) AS 'RECORDS'
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE CAR_ID in (SELECT CAR_ID
                  FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
                  WHERE START_DATE >= '2022-08-01' AND START_DATE <= '2022-10-31'
                  GROUP BY CAR_ID
                  HAVING COUNT(*) >= 5)
    AND START_DATE >= '2022-08-01' AND START_DATE <= '2022-10-31'
GROUP BY MONTH, CAR_ID
ORDER BY MONTH ASC, CAR_ID DESC


-- 카테고리 별 도서 판매량 집계하기 --
SELECT B.CATEGORY, SUM(S.SALES) AS TOTAL_SALES
FROM BOOK_SALES AS S JOIN BOOK AS B 
ON S.BOOK_ID = B.BOOK_ID
WHERE DATE_FORMAT(S.SALES_DATE, '%Y-%m') LIKE '2022-01'
GROUP BY B.CATEGORY
ORDER BY B.CATEGORY


-- 즐겨찾기가 가장 많은 식당 정보 출력하기 -- 
SELECT FOOD_TYPE, REST_ID, REST_NAME, FAVORITES
FROM REST_INFO
WHERE (FOOD_TYPE, FAVORITES) IN (SELECT FOOD_TYPE, MAX(FAVORITES)
                   FROM REST_INFO
                   GROUP BY FOOD_TYPE)
GROUP BY FOOD_TYPE
ORDER BY FOOD_TYPE DESC;


-- 조건별로 분류하여 주문상태 출력하기 --
SELECT ORDER_ID, PRODUCT_ID, DATE_FORMAT(OUT_DATE, '%Y-%m-%d'), CASE
WHEN DATE_FORMAT(OUT_DATE, '%Y-%m-%d') <= '2022-05-01' THEN '출고완료'
WHEN DATE_FORMAT(OUT_DATE, '%Y-%m-%d') > '2022-05-01' THEN '출고대기'
ELSE '출고미정'
END AS 출고여부
FROM FOOD_ORDER
ORDER BY ORDER_ID


-- 헤비 유저가 소유한 장소 --
SELECT ID, NAME, HOST_ID
FROM PLACES
WHERE HOST_ID IN (SELECT HOST_ID
                  FROM PLACES
                  GROUP BY HOST_ID
                  HAVING COUNT(ID) >= 2)


-- 오랜 기간 보호한 동물(1) --
SELECT NAME, DATETIME
FROM ANIMAL_INS
WHERE ANIMAL_ID NOT IN (SELECT O.ANIMAL_ID
                   FROM ANIMAL_OUTS AS O)
ORDER BY DATETIME
LIMIT 3;


-- 있었는데요 없었습니다 --
SELECT O.ANIMAL_ID, O.NAME
FROM ANIMAL_OUTS AS O JOIN ANIMAL_INS AS I
ON O.ANIMAL_ID = I.ANIMAL_ID
WHERE I.DATETIME >= O.DATETIME
ORDER BY I.DATETIME;


-- 없어진 기록 찾기 --
SELECT O.ANIMAL_ID, O.NAME
FROM ANIMAL_OUTS AS O
LEFT JOIN ANIMAL_INS AS I ON O.ANIMAL_ID = I.ANIMAL_ID
WHERE I.ANIMAL_ID IS NULL
ORDER BY O.ANIMAL_ID
